# Default values for nsi-safnari.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

image:
  registry: docker.io
  repository: hnstrmprt/nsi-safnari
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion.
  tag: ""

startupProbe:
  enabled: true
  scheme: "HTTP"
  path: "/healthcheck"
  failureThreshold: 30
  periodSeconds: 10
  timeoutSeconds: 5

livenessProbe:
  enabled: true
  scheme: "HTTP"
  path: "/healthcheck"
  failureThreshold: 5
  periodSeconds: 6
  timeoutSeconds: 5

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: false
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name: ""

podAnnotations: {}

podSecurityContext: {}
  # fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

service:
  name: "nsi-safnari"
  port: 80
  containerPort: 8080
# configure either ClusterIP or LoadBalancer + ipAddress
  type: ClusterIP
#  type: LoadBalancer
#  ipAddress: 1.2.3.4
#  annotations:
#    service.beta.kubernetes.io/azure-load-balancer-internal: "true"

ingress:
  enabled: false
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
      - path: /
        backend:
          serviceName: chart-example.local
          servicePort: 80
  tls:
    - secretName: chart-example-tls
      hosts:
        - chart-example.local

# if you do not want to use ingress annotations to generate the Certificate manifest
certificate:
  enabled: false
  name: chart-example-tls
  dnsName: example.domain.toplevel
  issuerRef:
    name: letsencrypt
  secretName: chart-example-tls
  privateKey:
    rotationPolicy: Always
  keystores:
    jks:
      create: false
      password: "secret"
    pkcs12:
      create: false
      password: "secret"

resources:
  requests:
    memory: 0.5Gi
    cpu: 100m
  limits:
    memory: 1.5Gi
    cpu: 1000m

nodeSelector: {}

tolerations: []

affinity: {}

postgresql:
  enabled: false
  postgresqlUsername: nsi-safnari-user
  postgresqlPassword:
  postgresqlDatabase: nsi-safnari
  postgresqlConfiguration:
    listenAddresses: '*'
  image:
    tag: 9.6.21
  persistence:
    size: 1Gi
  resources:
    requests:
      memory: 500Mi
  volumePermissions:
    enabled: true

secretProviderClass:
  enabled: false
  name:
  keyVaultName:
  tenantId:
  nodePublishSecretRefNname:
  env:
    - name: "PGHOST"
      value: "host.domain"
    - name: "PGPORT"
      value: 5432
  objects:
    - key: "PGDATABASE"
      objectName: "ns-safnari-db-name"
    - key: "PGPASSWORD"
      objectName: "ns-safnari-db-password"
    - key: "PGUSER"
      objectName: "ns-safnari-db-username"

config:
  #
  waitForPceUrl: http://development-nsi-pce.development.svc.cluster.local:80/paths
  #
  # nsi-safnari needs the following single configuration file:
  # - config-overrides.conf
  #
  # When config.configMapName is defined it must point to an existing configmap, managed outside of Helm,
  # that contains all necessary configuration files. Otherwise, Helm will create a configmap with files from
  # a folder pointed to by config.filesGlob, or the combination of config.inlineData and config.inlineBinaryData
  # is used. Note that filesGlob takes precedence over inline data.
  #
  # When config.keystore.secretName is defined it must point to an existing secret, managed outside of Helm,
  # the file pointed to by config.keystore.key will be mapped to nsi-safnari-keystore.jks. In this case the configmap
  # does not need to contain a keystore. To use a truststore from a secret use config.truststore.
  #
  mountPath: "/config"
  #configMapName: my-configmap-with-config
  #configFilesGlob: "config/*"
  inlineData: |-
    config-overrides.conf: |-
      include "application.conf"
      db.default.url = "jdbc:postgresql://"${PGHOST}"/"${PGDATABASE}
      db.default.password = ${PGPASSWORD}
      db.default.user = ${PGUSER}
      play {
        server {
          http {
            secret {
              key = ${SAFNARI_APPLICATION_SECRET}
            }
            port = 8080
            address = "0.0.0.0"
          }
        }
      }
      safnari {
        nsa {
          id = "urn:ogf:network:example.domain:2017:nsa:safnari"
          name = "Example Safnari"
        }
        network = null
        dds {
            url = "http://development-nsi-dds.development.svc.cluster.local:80"
        }
        peersWith = [
            { id = "urn:ogf:network:example.domain:2017:nsa", dn = "/C=NL/O=Example Org/OU=network services/CN=supa.example.org" },
        ]
        async.reply.timeout = 120 seconds
        connection.expiration.time = 1 day
      }
      pce {
        actor = real
        endpoint = "http://development-nsi-pce.development.svc.cluster.local:80"
        algorithm = sequential
      }
      nsi {
        actor = real
        base.url = "https://safnari.example.domain"
        twoway.tls = false
        tlsmap = {
        }
      }
      play.filters.hosts {
        allowed = ["."]
      }
      play.ws.ssl {
        keyManager = {
          stores = [
            {
              path = "/config/key/nsi-safnari-keystore.jks"
              type = "JKS"
              password = "secret"
            }
          ]
        }
        trustManager = {
          stores = [
            {
              path = "/config/trust/nsi-safnari-truststore.jks"
              type = "JKS"
              password = "secret"
            }
          ]
        }
      }
# When using inline key and trust stores, please replace the Lorem Ipsum below with actual stores.
  inlineBinaryData: |-
    nsi-safnari-keystore.jks: |-
      TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2Vk
      IGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlx
      dWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFt
      Y28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0
      ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1
      bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBj
      dXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1v
      bGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLgo=
    nsi-safnari-truststore.jks: |-
      TG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2Vk
      IGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlx
      dWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFt
      Y28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0
      ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1
      bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBj
      dXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1v
      bGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLgo=
  # Use keystore and truststore below to override the nsi-safnari-keystore.jks and/or nsi-safnari-truststore.jks
  # from the configmap above. For example to use a keystore generated by certmanager.
  keystore:
    #secretName: my-nsi-safnari-keystore
    #key: keystore.jks
  truststore:
    #secretName: my-nsi-safnari-truststore
    #key: truststore.jks
  # Create /config/trust/nsi-safnari-truststore.jks from ca.crt from caSecretName mounted under /ca
  caSecretName: ""
